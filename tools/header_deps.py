# Runs a compile command and then generates a make dependency file (.d) 
# for the input file's header dependencies. Additionally, merges
# dependencies generated by asm-processor (.asmproc.d).

import os
import re
import subprocess
import sys

include_regex = re.compile(r"#include [\"<](.*)[\">]")

class DepsScanner:
    def __init__(self, src_path: str) -> None:
        self.src_path = src_path
        self.deps = [src_path]
        self.resolved: "set[str]" = set()
    
    def scan(self):
        self.__parse_includes(self.src_path)

    def __parse_includes(self, file_path: str):
        # TODO: this should probably respect #if directives
        with open(file_path, "r") as file:
            # Find #include's in the file
            for line in file:
                match = include_regex.match(line)
                if not match:
                    continue
                # Resolve the full path
                include_path = self.__resolve(file_path, match.group(1))
                # If the path was resolved and not a duplicate, add it to the deps list
                if include_path and not include_path in self.resolved:
                    self.deps.append(include_path)
                    self.resolved.add(include_path)
                    # Recurse into included file
                    self.__parse_includes(include_path)
    
    def __resolve(self, src_path: str, include_path: str):
        # Try path relative to the file that included it
        relative_path = f"{os.path.dirname(src_path)}/{include_path}"
        if os.path.exists(relative_path):
            return relative_path
        else:
            # Otherwise, try from the include directory
            from_include_path = f"include/{include_path}"
            if os.path.exists(from_include_path):
                return from_include_path
            else:
                return None

def merge_asmproc(out_file_path: str, deps: "list[str]"):
    asmproc_path = f"{out_file_path[:-2]}.asmproc.d"
    
    if not os.path.exists(asmproc_path):
        # No .asmproc.d to merge
        return

    # Read deps for the same out file in .asmproc.d
    with open(asmproc_path, "r") as asmproc_file:
        at_in_file_line = False
        end = False
        for line in asmproc_file:
            if not at_in_file_line and line.startswith(out_file_path):
                at_in_file_line = True
                line = line.split(":")[1]
            
            if at_in_file_line:
                if line.endswith("\\\n"):
                    line = line[:-2].strip()
                else:
                    end = True
                    line = line.strip()
                
                asm_deps = line.split(" ")
                deps.extend(asm_deps)
                
            if end:
                break

def main():
    # Get full compile command
    args = sys.argv[1:]

    # Run command
    retcode = subprocess.call(args)

    # Don't output deps file if the command failed
    if retcode != 0:
        sys.exit(retcode)

    # Get in/out files from args
    in_file_path = args[-1]
    out_index = args.index("-o")
    out_file_path = args[out_index + 1]

    # Scan input file for header dependencies
    scanner = DepsScanner(in_file_path)
    scanner.scan()

    # Merge deps file generated by asm-processor (asmproc)
    deps = scanner.deps
    merge_asmproc(out_file_path, deps) 

    # Output deps file
    deps_file_path = f"{out_file_path}.d"

    with open(deps_file_path, "w", encoding="utf-8") as deps_file:
        chars = 0

        deps_file.write(out_file_path)
        deps_file.write(":")

        chars += len(out_file_path) + 1

        for dep in deps:
            str_len = len(dep) + 1
            # Line break at 80 characters (matches what gcc does)
            if chars + str_len >= 80:
                deps_file.write(" \\\n")
                chars = 0
            
            deps_file.write(" ")
            deps_file.write(dep)

            chars += str_len + 1
        
        deps_file.write("\n")

if __name__ == "__main__":
    main()
